<!doctype html><html lang=en><head><title>Artnoi.com - Cheat sheet for myself</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet><script src=/script.js></script></head><body><ul class=navbar id=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>logseq</a></li><li class=f-right><a href=/cheat/>cheat</a></li><li class=f-right><a href=/blog/>blog</a></li></ul><h1 id=cheat-sheet-for-myself>Cheat sheet for myself</h1><p><a href=#others>Other cheat sheets</a> are also available</p><h2 id=combining-find-1-with-rm-1>Combining <code>find(1)</code> with <code>rm(1)</code></h2><p><code>find(1)</code> is a very powerful UNIX tool. This example shows how we can find
and remove unwanted files recursively:</p><pre><code class=language-shell>find &lt;PATH&gt; -name &lt;NAME&gt; -exec rm -f {} \;
</code></pre><p>The example below will recursively remove file(s) <code>.DS_Store</code>,
starting from the working directory:</p><pre><code class=language-shell>find . -name '.DS_Store' -exec rm -f {} \;
</code></pre><h2 id=using-lsof-to-discover-process-running-on-a-port>Using <code>lsof</code> to discover process running on a port</h2><pre><code class=language-shell># macOS, and probably BSD
lsof -n -i TCP:6379;

# GNU/Linux
lsof -i :6379;
</code></pre><h2 id=posix-shell-parameter-expansion>POSIX shell parameter expansion</h2><p>People should know parameter expansion to avoid invoking (abusing) <code>cat(1)</code>,
<code>awk(1)</code>, <code>sed(1)</code>, and <code>grep(1)</code>.</p><p>However, when people use shell parameter expansion, they use non-POSIX syntax,
i.e. <code>bash</code>-specific syntax, which is not portable.</p><blockquote><p>The examples are for POSIX-compliant shell like UNIX <code>sh(1)</code> and <code>dash(1)</code>.
If you are using <code>bash(1)</code> and don&rsquo;t care about portability,
see <a href=https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html>reference manual for <code>bash(1)</code> shell</a>.
You can also see <code>dash</code> man pages for POSIX parameter expansion.</p></blockquote><h3 id=string-length>String length</h3><pre><code class=language-shell>FOO=&quot;foo&quot;;

echo ${#FOO}; # 3
</code></pre><h3 id=substring-prefix-removal-with>Substring: prefix removal with &lsquo;#&rsquo; (&lsquo;##&rsquo;)</h3><p>The variable name used in this demo will be <code>STR</code> with value <code>"foobar"</code>:</p><pre><code class=language-shell>STR='foobar';
</code></pre><p>Remove last 3 characters:</p><pre><code class=language-shell>echo ${STR#???}; # &quot;bar&quot;
</code></pre><p>Remove &lsquo;foo&rsquo; from start:</p><pre><code class=language-shell>echo ${STR#foo}; # &quot;bar&quot;
</code></pre><p>Remove &lsquo;fo&rsquo; (smallest pattern):</p><pre><code class=language-shell>echo ${STR#f*o}; # &quot;obar&quot;
</code></pre><p>Remove &lsquo;foo&rsquo; (largest pattern):</p><pre><code class=language-shell>echo ${STR##f*o}; # &quot;bar&quot;
</code></pre><h3 id=substring-suffix-removal-with>Substring: suffix removal with &lsquo;%&rsquo; (&lsquo;%%&rsquo;)</h3><p>The variable name used in this demo will be <code>STR</code> with value <code>"foobar"</code>:</p><pre><code class=language-shell>STR='foobar';
</code></pre><p>Remove first 2 characters</p><pre><code class=language-shell>echo ${STR%??}; # &quot;foob&quot;
</code></pre><p>Remove &lsquo;bar&rsquo; pattern from end:</p><pre><code class=language-shell>echo ${string%bar}; # &quot;foo&quot;
</code></pre><p>Remove pattern expands to &lsquo;obar&rsquo;:</p><pre><code class=language-shell>echo ${string%o*r}; # &quot;fo&quot;
</code></pre><p>Remove pattern expands to &lsquo;oobar&rsquo;:</p><pre><code class=language-shell>echo ${string%%o*r}; # &quot;f&quot;
</code></pre><p>The example below will move (i.e. rename) all files with <code>.text</code> extension to
<code>.txt</code> with a shell <code>for</code> loop (e.g. <code>token.text</code> -> <code>token.txt</code>):</p><pre><code class=language-shell>for f in *&quot;.text&quot;;
do
    mv &quot;${f}&quot; &quot;${f%.text}.txt&quot;;
done;
</code></pre><p>The example below will move all files starting with substring <code>gh</code> to be
starting with <code>github</code> instead (e.g. <code>gh_key</code> -> <code>github_key</code>):</p><pre><code class=language-shell>for f in &quot;gh&quot;*;
do
    mv &quot;${f}&quot; &quot;github${f#gh}&quot;;
done;
</code></pre><h3 id=substitution>Substitution</h3><p>I usually just use 2 of the many substitutions:</p><ul><li><p><code>${parameter:-word}</code> - use word as default value if <code>parameter</code> is null</p></li><li><p><code>${parameter:=word}</code> - assign word as default value if <code>parameter</code> is null</p></li></ul><p>These and their other variants are super-useful, and I wish I knew about these sooner.</p><p>Let&rsquo;s see some simple examples so you understand why these are useful:</p><pre><code class=language-shell>string0='test'; # string1 is still null
</code></pre><p>Use <code>string0</code> value if <code>string1</code> is null</p><pre><code class=language-shell># string1 is still null

echo ${string1}; # no output

echo ${string1:-$string0}; # &quot;test&quot;
</code></pre><p>Assign <code>string0</code> value if <code>string1</code> is null</p><pre><code class=language-shell>echo ${string1:=$string0}; # ouputs &quot;test&quot;, as well as assign &quot;test&quot; to string1

echo ${string1}; # outputs &quot;test&quot;
</code></pre><h2 id=redirecting-shell-output>Redirecting shell output</h2><blockquote><p><code>2>&amp;1</code> redirects stderr to stdout</p></blockquote><p>Discarding output and error messages:</p><pre><code class=language-shell>foo &gt; /dev/null 2&gt;&amp;1;
</code></pre><p>Writing to both stdout and file <code>out.txt</code>:</p><pre><code class=language-shell>foo 2&gt;&amp;1 | tee out.txt;
</code></pre><h2 id=using-dd-1>Using <code>dd(1)</code></h2><p>Writing a disk image from <code>image.iso</code> to USB flash drive <code>/dev/sdc</code>:</p><pre><code class=language-shell>dd bs=4M if=image.iso of=/dev/sdc status=progress oflag=sync;
</code></pre><p>Writing a key file with 2048 random bytes from special random character device <code>/dev/random</code>:</p><blockquote><p>In this case, use of <code>/dev/random</code> is <a href=https://man7.org/linux/man-pages/man4/random.4.html>prefered</a> over <code>/dev/arandom</code> and <code>/dev/urandom</code>.</p></blockquote><pre><code class=language-shell>dd bs=512 count=4 if=/dev/random of=&lt;DEST&gt; iflag=fullblock;
</code></pre><p>If you want a 4096-byte-long key file, use <code>count=8</code>.</p><h2 id=mounting-disk-images>Mounting disk images</h2><p>On <em>modern</em> GNU/Linux systems, we can mount partition images with option <code>loop</code>:</p><pre><code class=language-shell>mount -o loop image.iso /mnt;
</code></pre><h2 id=macos>macOS</h2><h3 id=updatedb-on-macos><code>updatedb</code> on macOS</h3><pre><code class=language-shell>sudo /usr/libexec/locate.updatedb;
</code></pre><h3 id=modifying-macos-system-files>Modifying macOS system files</h3><p>As of Catalina (10.15), the system files reside in their own encrypted read-only partition.</p><p>So if you wish to modify system files, disabling SIP alone is not enough - you will also have to remount the system partition with <em>write</em> permission:</p><pre><code class=language-shell>mount -uw / &amp;&amp; killall Finder;
</code></pre><h3 id=macos-native-ramdisk-hfs>macOS native ramdisk (HFS+)</h3><p>Ramdisks are perfect for temporary storage. I have had a habit where I edit my text files exclusively in <code>/tmp</code>.</p><p>It&rsquo;s a shame OS X does <em>not</em> ship with tmpfs OOTB. Nonetheless, we can still create a HFS+ ramdisk (of size 4GB) using utilities from the base install:</p><pre><code class=language-shell>diskutil erasevolume HFS+ 'RAM Disk' `hdiutil attach -nomount ram://8388608`;
</code></pre><p>Yes, the 5th argument is in back ticks.</p><blockquote><p>Hint: use the following value to specify block size: 524288 for 256MB, 1048576 for 512MB, 2097152 for 1GB, 4194304 for 2GB.</p></blockquote><h2 id=nfs-related>NFS-related</h2><h3 id=windows-10-pro-nfs-client>Windows 10 Pro NFS client</h3><p>You must first enable NFS client. You can do it in Powershell with:</p><pre><code class=language-PowerShell>Enable-WindowsOptionalFeatures -FeatureName ServicesforNFS-ClientOnly, ClientForNFS-Infrastructure -Online -NoRestart
</code></pre><p>Or from Control Panel > &ldquo;Programs&rdquo; > &ldquo;Turn Windows features on or off&rdquo; > &ldquo;Services for NFS&rdquo; > &ldquo;Client for NFS&rdquo;.</p><p>After you enabled NFS client, you can just use File Explorer to go to your remote location, e.g. <code>\\10.8.0.1\myshare</code> or use <code>NewPSDrive</code> to mount the NFS share:</p><pre><code class=language-PowerShell>New-PSDrive -Name &quot;Z&quot; -Root &quot;\\10.8.0.1\myshare&quot; -Persist -PSProvider &quot;Filesystem&quot;
</code></pre><p>Or use <code>mount</code> (which is alias to <code>New-PSDrive</code>) and fill up the argument by line.</p><p><code>Name</code> is desired Windows drive letter, and <code>Root</code> is the remote location, e.g.:</p><pre><code class=language-shell>mount
Name: Z
PSProvider: Filesystem
Root: \\10.8.0.1\myshare
</code></pre><p>You can list the shares with <code>Get-PSDrive</code> and unmount it with <code>Remove-PSDrive</code>.</p><h3 id=openbsd-nfs-client>OpenBSD NFS client</h3><p>Try mounting with option <code>-o tcp</code>. Also, recheck export list on the host, e.g. <code>foo</code>: <code>showmount -e foo</code>, and make sure to have NTP time sync enabled with the correct timezone.</p><h2 id=openbsd-configuraton>OpenBSD configuraton</h2><h3 id=hostname-if-5-https-man-openbsd-org-hostname-if-5-for-wg-4-https-man-openbsd-org-wg-wireguard-point-to-point-connection><a href=https://man.openbsd.org/hostname.if.5>hostname.if(5)</a> for <a href=https://man.openbsd.org/wg>wg(4)</a>: WireGuard point-to-point connection</h3><p>See also: <a href=https://artnoi.com/blog/2020/wireguard/>WireGuard on OpenBSD</a>.</p><pre><code># Interface configuration
wgkey yourPrivKey=
wgport 6969
inet 10.8.1.4/24
up

# WireGuard peers
!ifconfig wg0 wgpeer peer1pubkey= wgendpoint 192.168.2.3 5555 wgaip 10.8.1.1/32
!ifconfig wg0 wgpeer peer2pubkey= wgendpoint example.com 9696 wgaip 10.8.1.2/32
!ifconfig wg0 wgpeer peer3pubkey= wgaip 10.8.1.3/32
</code></pre><h3 id=pf-conf-5-https-man-openbsd-org-pf-conf-for-wg-4-https-man-openbsd-org-wg><a href=https://man.openbsd.org/pf.conf>pf.conf(5)</a> for <a href=https://man.openbsd.org/wg>wg(4)</a></h3><pre><code># pf.conf(5) for WireGuard

pass in on egress inet proto udp\
    from any to any port 6969

pass out on egress inet\
    from (wg0:network) nat-to (egress:0)
</code></pre><h3 id=relayd-conf-5-https-man-openbsd-org-relayd-conf-5-relaying-ssh-connection><a href=https://man.openbsd.org/relayd.conf.5>relayd.conf(5)</a>: relaying SSH connection</h3><pre><code>protocol &quot;myssh&quot; {
    tcp {
        nodelay
        socket buffer 65536
    }
}

relay &quot;sshforward&quot; {
    listen on www.example.com port 2222
    protocol &quot;myssh&quot;

    forward to shell.example.com port 22
}
</code></pre><h3 id=relayd-conf-5-https-man-openbsd-org-relayd-conf-5-redirecting-dns-connection><a href=https://man.openbsd.org/relayd.conf.5>relayd.conf(5)</a>: redirecting DNS connection</h3><pre><code>redirect &quot;dns&quot; {

  listen on dns.example.com\
    tcp port 53

  listen on dns.example.com\
    udp port 53

  forward to &lt;dnshosts&gt;\
    port 53 check tcp
}
</code></pre><h3 id=httpd-8-with-tls-https>httpd(8) with TLS (HTTPS)</h3><p>See <a href=/blog/2020/openbsd-server/>this blog</a>.</p><h3 id=installing-openbsd-with-full-disk-encrpytion-on-vultr-https-vultr-com>Installing OpenBSD with full-disk encrpytion on <a href=https://vultr.com>Vultr</a></h3><p>See <a href=/blog/2020/openbsd/>this blog</a>.</p><h2 id=gnu-linux-only>GNU/Linux only</h2><h3 id=systemd-drop-in-configuration>systemd drop-in configuration</h3><p>Drop-ins are parsed and overrides global configuration. The files are read alphabetically, so file <code>00-override</code> loads before <code>100-override</code>, i.e. <code>00</code> is overridden by <code>100</code>.</p><h3 id=systemd-service-failure>systemd service failure</h3><p>If <code># systemctl status</code> returned <em>degraded</em>, we can issue:</p><pre><code class=language-shell>systemctl reset-failed;
</code></pre><p>to fix the failed units.</p><h3 id=systemd-journald-auth-log>systemd (journald) auth.log</h3><pre><code class=language-shell>journalctl SYSLOG_FACILITY=10;
</code></pre><h3 id=persistent-iptables-dropping-incoming-traffic>Persistent <code>iptables</code> dropping incoming traffic</h3><p>On Arch Linux, Systemd service <code>iptables.service</code> will load configuration <code>/etc/iptables/ipatbles.rules</code> on startup if the service is enabled. The file originally has blank fules.</p><p>To configure <code>iptables</code> such that it drops all incoming connections (in a usable way), change the configuration to:</p><blockquote><p>From <a href=https://superuser.com/questions/427458/deny-all-incoming-connections-with-iptables>superuser.com</a></p></blockquote><pre><code>*filter

:FORWARD DROP [0:0]

:OUTPUT ACCEPT [623107326:1392470726908]

:INPUT DROP [11486:513044]

-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

-A INPUT -i lo -j ACCEPT

-4 -A INPUT -p icmp -j ACCEPT
-6 -A INPUT -p ipv6-icmp -j ACCEPT

# Add exception rules here
#-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
#-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
#-A INPUT -p tcp -m tcp --dport 443 -j ACCEPT

COMMIT
</code></pre><p>Also, enable the service (otherwise you would have to use <code>iptables-restore</code> each time you reboot):</p><pre><code class=language-shell>systemctl enable --now iptables;
</code></pre><h3 id=changing-storage-device-designation-e-g-sdx1-to-sdx4>Changing storage device designation, e.g. sdX1 to sdX4</h3><p>Look for answer edited/posted by users <strong>drs</strong> and <strong>Joao S Veiga</strong> on <a href=https://unix.stackexchange.com/questions/18752/change-the-number-of-the-partition-from-sda1-to-sda2>unix.stackexchange.com</a></p><h3 id=force-unmounting-after-a-chroot-operation>Force unmounting after a chroot operation</h3><p>After exitting from a <code>chroot</code> environment, if you find yourself unable to unmount certain mountpoints (target busy, etc), try following the <a href=#my-other-cheat-sheet-links>Linux LVM guide below</a> first if your chroot environment is on LVM.</p><p>If all else failed, and you want to <em>force</em> unmount the mountpoint, issue:</p><pre><code class=language-shell>umount -lf /mountpoint;
</code></pre><p>This will <a href=https://unix.stackexchange.com/questions/61885><em>force detach filesystem from fs heirarchy, and cleanup all references to the filesystem as soon as it&rsquo;s not busy</em></a></p><h3 id=console-backlight>Console backlight</h3><p>Most distributions place their console brightness configuration in <code>/sys/class/backlight/xxx/brightness</code></p><h2 id=certbot-with-nginx>certbot (with NGINX)</h2><p>Certbot can be used to automatically get new certificates and update your NGINX configuration to enable HTTPS in one command.</p><p>To obtain certificates (including the subdomains), and have Certbot modify your NGINX configuration, run:</p><pre><code class=language-shell>certbot --nginx -d &lt;DOMAIN_0&gt; [-d &lt;DOMAIN_1&gt;];
</code></pre><p>To see certificate information, run:</p><pre><code class=language-shell>certbot certificates;
</code></pre><p>To force-renew certificates <em>without reinstalling</em> the certificates (i.e. the NGINX configuration would <em>not</em> be modified), run:</p><pre><code class=language-shell>certbot certonly --force-renewal -d &lt;DOMAIN&gt;;
</code></pre><p>Or, if you have setup webroot:</p><pre><code class=language-shell>certbot certonly --webroot -w &lt;WEBROOT_DIR&gt; -d &lt;DOMAIN_NAME&gt;;
</code></pre><p>On Arch Linux with NGINX, include this snippet in your NGINX configuration to enable webroot:</p><pre><code>location ^~ /.well-known/acme-challenge/ {
    allow all;
    root /var/lib/letsencrypt/;
    default_type &quot;text/plain&quot;;
    try_files $uri =404;
}
</code></pre><p>The snippet above should be put in a <code>server</code> block
that listens on standard HTTP port 80.</p><p>For NGINX to serve HTTPS, add the following snippet to <code>server</code> block
listening on port 443.</p><pre><code>ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

include /etc/letsencrypt/options-ssl-nginx.conf;
ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
</code></pre><p>On FreeBSD, the package recommends putting the following line
in <code>/etc/periodic.conf</code> so that certbot will renew certificates periodically:</p><pre><code>weekly_certbot_enable=&quot;YES&quot;
</code></pre><p>Artnoi.com used both <code>cron</code> and <code>periodic.conf</code> schedulers when it was running
on FreeBSD and NGINX. Now it runs <a href=https://artnoi.com/blog/2020/openbsd-server/>OpenBSD</a>.</p><h2 id=screenshots-on-sway>Screenshots on Sway</h2><p>My prefered way to do this is to use 2 separate programs to take screenshots,
(1) <code>slurp</code> for selecting a region, (2) <code>grim</code> for actually capturing the image:</p><blockquote><p>The man page suggests that <code>-o &lt;OUTFILE></code> can be used to specify output file,
however, my experience in October 2022 was that <code>-o</code> flag does not work,
and you can just supply the outfile name as last argument.</p></blockquote><pre><code class=language-shell>grim -g &quot;$(slurp -d)&quot; /tmp/scrot.png
</code></pre><p>Or, if you want to redirect the output to stdout to <code>wl-copy</code>:</p><pre><code class=language-shell>grim -g &quot;$(slurp -d)&quot; - | wl-copy -t 'image/png';
</code></pre><p>This will capture the screenshot selected and piped to <code>wl-copy</code>.</p><h2 id=a-name-others-a-my-other-cheat-sheet-links><a name=others></a>My other cheat sheet links</h2><p><a href=/cheat/arch/>Arch Linux cheat sheet</a></p><p><a href=/blog/2019/arch-zfs/>Arch Linux ZFS root</a></p><p><a href=/cheat/zfs/>ZFS cheat sheet</a></p><p><a href=/cheat/device-mapper/>Device Mapper - LUKS and LVM</a></p><p><a href=/cheat/git/>Git cheat sheet</a></p><h2 id=my-cheat-sheet-links-for-noob-friends-noob><a href=/noob/>My cheat sheet links for noob friends</a></h2><p><a href=/noob/block/>Storage (disks, etc.)</a></p><p><a href=/noob/boot/>Booting the computer</a></p><p><a href=/noob/desktop/>Minimal UNIX desktop</a></p><p><a href=/noob/vim/>Vim for noobs</a></p><hr><p><a href=#top>Back to top</a></p><hr><footer><p>Copyright (c) 2019 Prem Phansuriyanon</p><p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p></footer></body></html>