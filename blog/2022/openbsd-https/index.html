<!doctype html><html lang=en><head><title>Artnoi.com - Hosting a HTTPS website with OpenBSD `httpd`, and optionally `relayd`</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet><script src=/script.js></script></head><body><ul class=navbar id=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>logseq</a></li><li class=f-right><a href=/cheat/>cheat</a></li><li class=f-right><a href=/blog/>blog</a></li></ul><p>Aug 13, 2022</p><h1 id=hosting-a-https-website-with-openbsd-httpd-and-optionally-relayd>Hosting a HTTPS website with OpenBSD <code>httpd</code>, and optionally <code>relayd</code></h1><p><a href=/blog/2022/reset/>After my old servers were compromised</a>, the first thing I do is to setup a new OpenBSD webserver. This makes sense, because of how OpenBSD is wonderfully suited for this task. The fact that the operating system ships with HTTP server, a well written <code>relayd(8)</code> for level-3 redirection and level-7 relays, a robust firewall (<code>pf(4)</code>), a robust VPN driver built into the kernel (<code>wg(4)</code>), and finally, a native ACME client <code>acme-client(1)</code>!</p><p>Out of the box, OpenBSD is perfect right at the beginning for being a secure webserver! Ever since I first wrote the <a href=/blog/2020/openbsd-server/>tutorial to create an OpenBSD webserver in 2020</a>, nothing (in the eye of the users) about the software has changed, but one thing has changed - I have more experience now. When I first wrote that article, I was not working in tech industry, did not write any programs other than shitty shell scripts, and tended to overengineer stuff.</p><p>This time, it&rsquo;ll be different. Everything will only be added if needed. Before we dive to the config files, let&rsquo;s first discuss my desired HTTP server behavior.</p><h2 id=desired-httpd-8-behavior>Desired <code>httpd(8)</code> behavior</h2><p>I want only 1 main virtual server, that is, <strong>there&rsquo;ll be only 1 virtual server that does the actual serving of HTML files</strong>. Other virtual servers are for redirecting subdomains <strong>back to the main virtual servers</strong>.</p><p>I also want <code>httpd(8)</code> to be somewhat more secure than my old front-end reverse proxy, NGINX. In OpenBSD, <code>httpd(8)</code> is run as user <code>www</code> by default. It does not matter if you run the webserver on the previleged ports or not - <code>httpd</code> will (by default) chroot <code>/var/www</code>, and will only see files in there. If <code>httpd</code> is compromised, then only the files user <code>www</code> has write permission to will be affected.</p><p>My main requirement is to have subdomains, and all those subdomains share the same ACME certificate. All those subdomains are only for user convenience, and <code>httpd(8)</code> subdomain vurtual servers should redirect to the main virtual server.</p><p>In the final stage, I want my webserver to</p><ul><li><p>Main webserver is on host <code>artnoi.com</code>, where we have the <code>root</code> directive for our HTML files.</p></li><li><p>Redirect all HTTP traffic to HTTPS</p></li><li><p>Handle HTTP ACME auth in <code>/.well_known/acme-challenge</code> despite other locations being redirected to HTTPS</p></li><li><p>Redirect <code>www.artnoi.com</code> to <code>artnoi.com</code></p></li><li><p>For subdomains other that <code>www</code>, do redirections like <code>artnoi.com/cheat/foo</code> to <code>artnoi.com/cheat/foo</code></p></li></ul><h2 id=using-only-httpd-8-for-standard-http>Using only <code>httpd(8)</code> for standard HTTP</h2><p>You must first setup a simple webserver on your box and obtain ACME certificates/key for your domain and subdomains. To do just that, setup a simple webserver just for ACME auth:</p><pre><code># httpd.conf

prefork 5

# This virtual server can also handle ACME auth in HTTPS
server &quot;artnoi.com&quot; {
	alias &quot;www.artnoi.com&quot;
	alias &quot;artnoi.com/cheat&quot;
	alias &quot;noob.artnoi.com&quot;
	alias &quot;zv.artnoi.com&quot;

	listen on * port 80

	location &quot;/.well-known/acme-challenge/*&quot; {
		root &quot;/acme&quot;
		request strip 2
	}
}
</code></pre><p>Now, configure <code>acme-client.conf(5)</code> such that we can use 1 ACME <em>fullchain</em> certificate for all subdomains:</p><pre><code># acme-client.conf
authority letsencrypt {
	api url &quot;https://acme-v02.api.letsencrypt.org/directory&quot;
	account key &quot;/etc/acme/letsencrypt-privkey.pem&quot;
}

domain artnoi.com {
	alternative names { www.artnoi.com artnoi.com/cheat noob.artnoi.com zv.artnoi.com }
	domain key &quot;/etc/ssl/private/artnoi.com.key&quot;
	domain full chain certificate &quot;/etc/ssl/artnoi.com.crt&quot;
	#domain certificate &quot;/etc/ssl/artnoi.com.crt&quot;
	#domain full chain certificate &quot;/etc/ssl/artnoi.com.fullchain.pem&quot;
	sign with letsencrypt
}
</code></pre><p>Normally, <code>relayd</code> would look for the following keypair: <code>/etc/ssl/private/$name.key</code> and <code>/etc/ssl/$name.crt</code>. But if we did not use <code>domain full chain certificate</code> as <code>/etc/ssl/name.crt</code>, some clients like <code>curl</code> might complain that our certificate is not good enough. This is why re omitted <code>domain certificate</code>, and use <code>domain full chain certificate</code> for our <code>artnoi.com.crt</code> file.</p><p>Now, start <code>httpd(8)</code> and run <code>acme-client(1)</code>:</p><pre><code># httpd -n &amp;&amp; rcctl start httpd;
# acme-client -v artnoi.com;
</code></pre><p>You can now proceed to setup a full HTTPS webserver if ACME challenge was successful and you got the certificates/key configured in <code>acme-client.conf</code> in <code>/etc/ssl</code>.</p><h2 id=using-only-httpd-8-to-serve-https>Using only <code>httpd(8)</code> to serve HTTPS</h2><blockquote><p>Note that the <code>root</code> directive is relative to <code>/var/www</code>.</p></blockquote><pre><code>prefork 5

public_interface = &quot;vio0&quot;
public_ip = &quot;139.180.157.32&quot;

types {
	# uncomment 'include' line below to use all types
	# include &quot;/usr/share/misc/mime.types&quot;
	application/pdf pdf
	image/png       png
	image/svg+xml   svg ico
	text/css        css
	text/html       html htm
	text/plain      txt
}

# This virtual server &quot;artnoi.com&quot; is the main virtual HTTPS server
# to which all other subdomain virtual servers redirect to.
#
# This virtual server can also handle ACME auth in HTTPS
server &quot;artnoi.com&quot; {
	alias &quot;www.artnoi.com&quot;
	listen on $public_interface tls port 443
	root &quot;/htdocs/www.artnoi.com&quot;

	tls {
		certificate &quot;/etc/ssl/artnoi.com.fullchain.pem&quot;
		key &quot;/etc/ssl/private/artnoi.com.key&quot;
	}
}

# This virtual &quot;artnoi.com&quot; server serves 2 purposes
# 1. Handle ACME auth for subdomains
# 2. Redirect non-ACME connection to HTTPS
#
# This virtual server is for &quot;artnoi.com&quot;/&quot;www.artnoi.com&quot;,
# so redirection simply returns https://$HTTP_HOST$REQUEST_URI.
server &quot;artnoi.com&quot; {
	alias &quot;www.artnoi.com&quot;
	listen on $public_interface port 80

	location &quot;/.well-known/acme-challenge/*&quot; {
		root &quot;/acme&quot;
		request strip 2
	}
	location * {
		block return 301 &quot;https://$HTTP_HOST$REQUEST_URI&quot;
	}
}

# These other subdomain virtual webservers are different than the one above,
# because we want to change the request host and URI too, and that new request
# should point to our main virtual server &quot;artnoi.com&quot; on 443.
#
# &quot;http://artnoi.com/cheat/foo&quot; should be redirected to 'https://artnoi.com/cheat/foo'
server &quot;artnoi.com/cheat&quot; {
	listen on $public_interface port 80

	# Redirect to the virtual server above for ACME challenges
	location &quot;/.well-known/acme-challenge/*&quot; {
		block return 301 &quot;http://artnoi.com$REQUEST_URI&quot;
	}

	location * {
		block return 301 &quot;https://artnoi.com/cheat$REQUEST_URI&quot;
	}
}

# &quot;http://noob.artnoi.com/foo&quot; should be redirected to 'https://artnoi.com/noob/foo'
server &quot;noob.artnoi.com&quot; {
	listen on $public_interface port 80

	# Redirect to the virtual server above for ACME challenges
	location &quot;/.well-known/acme-challenge/*&quot; {
		block return 301 &quot;http://artnoi.com$REQUEST_URI&quot;
	}

	location * {
		block return 301 &quot;https://artnoi.com/noob$REQUEST_URI&quot;
	}
}

# &quot;http://zv.artnoi.com/foo&quot; should be redirected to 'https://artnoi.com/noob/foo'
server &quot;zv.artnoi.com&quot; {
	listen on $public_interface port 80

	# Redirect to the virtual server above for ACME challenges
	location &quot;/.well-known/acme-challenge/*&quot; {
		block return 301 &quot;http://artnoi.com$REQUEST_URI&quot;
	}

	location * {
		block return 301 &quot;https://artnoi.com/noob$REQUEST_URI&quot;
	}
}
</code></pre><p>Now, while this configuration works, something is missing - we haven&rsquo;t configure proper HTTP headers. This will leave both the users and servers vulnerable to man-in-the-middle or other attacks</p><h2 id=using-httpd-8-with-relayd-8-to-modify-http-headers-and-tls-acceleration>Using <code>httpd(8)</code> with <code>relayd(8)</code> to modify HTTP headers and TLS acceleration</h2><p>For our server to serve with secure HTTP request headers, we can use <code>relayd</code> to do that job. This means that, instead of having <code>httpd(8)</code> listening on port <code>80</code> and <code>443</code> for both HTTP and HTTPS request, we can use <code>relayd</code> as the frontend first (for both HTTP and HTTPS), and have it modify our HTTP headers as it relays the request to <code>httpd(8)</code>!</p><p>For this, we need to</p><ol><li><p>Make <code>httpd(8)</code> listen on an internal HTTP address, e.g. <code>127.0.0.1:8888</code></p></li><li><p>Set <code>relayd(8)</code> to listen on both 443 (TLS/HTTPS) and 80 (HTTP), and forward the connections to <code>127.0.0.1:8888</code> where our <code>httpd(8)</code> is listening</p></li></ol><p>Let&rsquo;s start with updating our <code>httpd.conf(5)</code> virtual server blocks to listen HTTP on <code>127.0.0.1:8888</code> instead:</p><h3 id=updating-httpd-conf-5>Updating <code>httpd.conf(5)</code></h3><blockquote><p>Note: you can see that there&rsquo;s no <code>tls</code> directive in <code>httpd.conf(5)</code> anymore.</p></blockquote><pre><code>prefork 5
this_server = &quot;127.0.0.1&quot;
internal_httpd_port = &quot;8888&quot;

types {
	# uncomment 'include' line below to use all types
	# include &quot;/usr/share/misc/mime.types&quot;
	application/pdf pdf
	image/png       png
	image/svg+xml   svg ico
	text/css        css
	text/html       html htm
	text/plain      txt
}

server &quot;artnoi.com&quot; {
	alias &quot;www.artnoi.com&quot;
	listen on $this_server port $internal_httpd_port
	root &quot;/htdocs/html-artnoi.com&quot;

	location &quot;/.well-known/acme-challenge/*&quot; {
		root &quot;/acme&quot;
		request strip 2
	}
}

server &quot;artnoi.com/cheat&quot; {
	listen on $this_server port $internal_httpd_port

	location &quot;/.well-known/acme-challenge/*&quot; {
		block return 301 &quot;http://artnoi.com$REQUEST_URI&quot;
	}
	location * {
		block return 301 &quot;https://artnoi.com/cheat$REQUEST_URI&quot;
	}
}

server &quot;noob.artnoi.com&quot; {
	listen on $this_server port $internal_httpd_port

	location &quot;/.well-known/acme-challenge/*&quot; {
		block return 301 &quot;http://artnoi.com$REQUEST_URI&quot;
	}
	location * {
		block return 301 &quot;https://artnoi.com/noob$REQUEST_URI&quot;
	}
}

server &quot;zv.artnoi.com&quot; {
	listen on $this_server port $internal_httpd_port

	location &quot;/.well-known/acme-challenge/*&quot; {
		block return 301 &quot;http://artnoi.com$REQUEST_URI&quot;
	}
	location * {
		block return 301 &quot;https://artnoi.com/noob$REQUEST_URI&quot;
	}
}
</code></pre><p>Restart <code>httpd(8)</code>. It should now be listening on port <code>8080</code>.</p><h3 id=updating-relayd-conf-5>Updating <code>relayd.conf(5)</code></h3><p>One trick here is that we will not be specifying <code>tls keypair "artnoi.com"</code> here. This is because by default, <code>relayd(8)</code> looks for file <code>/etc/ssl/private/${ip_addr:port}.key</code> and <code>/etc/ssl/{ip_addr:port}.crt</code> for each <code>listen</code> directive. Since we will have <code>relayd(8)</code> listen on public IP address <code>69.69.69.69</code>, we&rsquo;ll have to symlink the private key and full chain certificate for the address.</p><pre><code># # Use full chain cert (.pem) as 69.69.69.69.crt
# ln -s /etc/ssl/{artnoi.com.fullchain.pem,69.69.69.69.crt}
# ln -s /etc/ssl/private/{artnoi.com,69.69.69.69}.key
</code></pre><p>This will allow us to omit <code>tls keypair ..</code> in <code>relayd.conf(5)</code>. And after the webserver is running, we can now create a <code>relayd.conf</code> configuration that looks something like this:</p><pre><code>public_interface = &quot;69.69.69.69&quot;
this_box = &quot;127.0.0.1&quot;

httpd_port = &quot;8888&quot;

table &lt;httpd&gt; { $this_box }
table &lt;dns_hosts&gt; { $this_box }

http protocol &quot;httpfilter&quot; {
	# set recommended tcp/tls options
	tcp { nodelay, sack, socket buffer 65536, backlog 100 }
	tls { no tlsv1.2 }

	# Return HTTP/HTML error pages to the client
	return error
	match header append &quot;X-Forwarded-For&quot; value &quot;$REMOTE_ADDR&quot;
	match header append &quot;X-Forwarded-By&quot; value &quot;$SERVER_ADDR:$SERVER_PORT&quot;
	match header append &quot;Keep-Alive&quot; value &quot;$TIMEOUT&quot;

	# See https://securityheaders.com to check and modify headers as needed below
	match response header remove &quot;Server&quot;
	match response header set &quot;Content-Security-Policy&quot; value &quot;default-src 'self'; style-src 'self'; img-src 'self'; base-uri 'self'; frame-ancestors&quot;
	match response header set &quot;X-Frame-Options&quot; value &quot;deny&quot;
	match response header set &quot;X-XSS-Protection&quot; value &quot;1; mode=block&quot;
	match response header set &quot;X-Content-Type-Options&quot; value &quot;nosniff&quot;
	match response header set &quot;Referrer-Policy&quot; value &quot;no-referrer&quot;

	match response header set &quot;Feature-Policy&quot; value &quot;accelerometer 'none'; camera 'none'; geolocation 'none'; gyroscope 'none'; magnetometer 'none'; microphone 'none'; payment 'none'; usb 'none'&quot;
	match response header set &quot;Permissions-Policy&quot; value &quot;fullscreen=(), geolocation=(), microphone()&quot;
	match response header set &quot;Strict-Transport-Security&quot; value &quot;max-age=31536000; includeSubdomains; preload&quot;

	match query hash &quot;sessid&quot;
	block path &quot;/cgi-bin/index.cgi&quot; value &quot;*command=*&quot;

	#pass request quick header &quot;Host&quot; value &quot;artnoi.com&quot; forward to &lt;httpd&gt;
	#pass request quick header &quot;Host&quot; value &quot;www.artnoi.com&quot; forward to &lt;httpd&gt;
	#pass request quick header &quot;Host&quot; value &quot;artnoi.com/cheat&quot; forward to &lt;httpd&gt;
	#pass request quick header &quot;Host&quot; value &quot;noob.artnoi.com&quot; forward to &lt;httpd&gt;
	#pass request quick header &quot;Host&quot; value &quot;zv.artnoi.com&quot; forward to &lt;httpd&gt;
	#pass request quick header &quot;Host&quot; value &quot;chat.example.com&quot; forward to &lt;synapse&gt;
}

relay &quot;www4secure&quot; {
	listen on $public_interface port 443 tls
	protocol httpfilter
	forward to &lt;httpd&gt; port $httpd_port mode loadbalance check tcp
}

relay &quot;www4&quot; {
	listen on $public_interface port 80
	protocol httpfilter
	forward to &lt;httpd&gt; port $httpd_port mode loadbalance check tcp
}
</code></pre><p>With these configurations, <code>relayd(8)</code> now acts as both TLS accelerator, HTTP headers filter, and reverse HTTP proxy for <code>httpd(8)</code>. We can replicate the backend webservers a lot of times, and all we have to do is to add newer webservers to our <code>relayd.conf(5)</code> in the table <code>&lt;httpd_servers></code>.</p><h2 id=misc>Misc.</h2><p>You can check validity of your configurations with <code>-n</code> flag, e.g. <code>httpd -n</code>, which will test the default <code>/etc/httpd.conf</code>. To test a specific file, you can combine <code>-n</code> with <code>-f</code>, e.g. <code>relayd -n -f /etc/relayd-ng.conf</code>.</p><h3 id=wireguard-vpn>Wireguard VPN</h3><p>Since OpenBSD ships with <code>wg(4)</code>, we can basically write a <code>hostname.if(5)</code> file and create the network interface for our Wireguard connection. In this example, I&rsquo;ll be using <code>wg1</code>, so the configuration file is <code>/etc/hostname.wg1</code>:</p><pre><code># /etc/hostname.wg1
# Interface configuration
wgkey 6HTy5ej5gg2nN4rocwhinQx+XtIQ9SDa7vH3dIfTr1E=
wgport 6969
inet 192.168.69.1/24
up

# Wireguard peers
!ifconfig wg1 wgpeer wizxPD/5eTb0qyEx2uHtWCPDZ9EM4aLVLX4JcW4ui2k= wgendpoint 10.10.0.1 51543 wgaip 192.168.69.2/32
!ifconfig wg1 wgpeer d4hwbjlHKlUE6kyq/4ZEKnroD6LDfetE8op6bUk6KGo= wgpsk 6ibR/T+WzbztlqdPKVs5Nbho7Q/riD3Hy1rNEKPuD+0= wgaip 192.168.69.3/32
</code></pre><hr><p><a href=#top>Back to top</a></p><hr><footer><p>Copyright (c) 2019 Prem Phansuriyanon</p><p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p></footer></body></html>