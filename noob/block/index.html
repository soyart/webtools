<!doctype html><html lang=en><head><title>Artnoi.com - Block data storage</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet><script src=/script.js></script></head><body><ul class=navbar id=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>logseq</a></li><li class=f-right><a href=/cheat/>cheat</a></li><li class=f-right><a href=/blog/>blog</a></li></ul><h1 id=block-data-storage>Block data storage</h1><h2 id=memory>Memory?</h2><blockquote><p>FYI: Volatile memory means that the device loses data the exact moment power is removed (i.e. turned off), while non-volatile (persistent) memory refers to those devices capable of retaining data after power is removed. Example of volatile memory is RAM, and one for non-volatile memory is an SD card.</p></blockquote><p>When we talk about <a href=https://en.wikipedia.org/wiki/Computer_memory>computer memory</a> or storage, we must be specific, since terms are just so ambiguous in computers.</p><p>Memory can mean volatile memory like RAM, or non-volatile (persistent) but read-only like ROM, and storage could just mean how to store your smoking hot computers in summer.</p><p>This page is about non-volatile computer memory, which is likely the memory whose size is largest in your systems. It is where you keep your persistent data, i.e. save files.</p><p>Before you begin, keep in mind that everything in computers is an abstraction - with files being top-most, and the actual hardware being in the lowest bottom.</p><blockquote><p>Command examples are not provided here, look for it instead in the main <a href=/noob/>Linux newbie guide page</a>.</p></blockquote><h2 id=disk-partition-and-filesystem-linux-centric>Disk, partition, and filesystem (Linux-centric)</h2><h3 id=general-use>General use</h3><p>In general, we first partition the disk (using <code>fdisk</code> or equivalents), then create a filesystem on the partition. We then mount the filesystem to our mountpoint, and read/write files from that mountpoint.</p><p>Most consumer operating systems (macOS, Windows) automatically detect new block devices and partitions, and mount the filesystems on them automatically, and that&rsquo;s why most people have no idea about mounting filesystems.</p><h3 id=disk>Disk</h3><p>A <em>disk</em> (and other storage devices) is hardware with which we store our data, usually files. The storage devices store data in blocks (sectors), hence the name <em>block device</em>.</p><p>On Linux systems, <code>lsblk</code> lists the block device names. We can <em>read</em> data from block devices, as well as <em>write</em> data to them directly, like when we use <code>dd</code> to write (i.e. <em>flashing</em> or <em>burning</em>) a distro install <code>iso</code> image to a flash drive. We can also wipe the disk entirely by writing zeroes or random data to it.</p><p>But to store data as files on disks in a sane manner, that is, for the files to be conveniently read and written, we need partitions and filesystems.</p><blockquote><p>Block devices can be found as device files in <code>/dev</code>, e.g. <code>/dev/sda</code>, <code>/dev/nvme0n1</code>, <code>/dev/mmcblk0</code>.</p></blockquote><h3 id=partition>Partition</h3><p>Partitioning is division of the blocks on a disk into smaller ones for flexibility and manageability. Each partition can have its own separate <em>filesystem</em>, which can be <em>mounted</em> separately.</p><p>Think of disks as one large grid of empty space. We can <em>partition</em> that giant space into smaller ones, then allocate these divisions for their specific use, and then use the different partitions separately.</p><p>Partitions, just like block devices, can be found in <code>/dev</code>, e.g. <code>/dev/sda1</code>, <code>/dev/nvme0n1p1</code>, <code>/dev/mmcblk0p1</code>.</p><h3 id=optional-logical-volume-device-mapper>(Optional) Logical volume/ Device mapper</h3><p>Other than using physical partitions, we can logically manage the disks/partitions into <em>logical</em> partitions.</p><p>Usually, these <em>logical volumes</em> are managed by a logical volume manager, e.g. LVM in the Linux kernel, and Core Storage in Apple systems.</p><p>These block device virtualization techniques are very useful if you can figure out how to use it, and they also keep our physical partition tables clean and less likely to be re-partitioned which risks losing data.</p><blockquote><p>In Linux systems, LVM works as a framework under <a href=https://en.wikipedia.org/wiki/Device_mapper>device mapper</a>, and so can be found in <code>/dev/mapper</code>, e.g. <code>/dev/mapper/cryptroot</code>, <code>/dev/mapper/WDBlue-raid</code></p></blockquote><h3 id=filesystem>Filesystem</h3><p>Filesystem can be ambiguous, as it commonly refers to both the programs used to read/write files, and the on-disk format of data organization used by such filesystem programs.</p><p>For example, <code>EXT4</code> refer to both the software responsible for handling <code>EXT4</code> formatted disk, and also the actual data stored in <code>EXT4</code> format on the disk.</p><p>To store and read files, the operating systems uses special programs (usually run in kernel space) called filesystems to deal with the files.</p><p>These filesystems read and write files for the OS, and the OS abstracts the filesystem layer for other programs when they need to read or write files.</p><p>So all the other programs see is files, not the disks or other lower-level abstraction.</p><p>Each filesystem programs manage files differently (i.e. each has different on-disk layout, or <em>format</em>), although some of them are compatible with one another, as in the case of <code>EXT</code> family of filesystems in the Linux kernel.</p><p>The filesystems keep track of everything - what files is stored on what blocks, time each file is last written/read, as well as other metadata, like <a href=https://en.wikipedia.org/wiki/Journaling_file_system>journals</a> and <a href=https://en.wikipedia.org/wiki/Checksum>checksums</a> for additional data integrity.</p><p>Examples of filesystems include <code>EXT2</code>, <code>EXT3</code>, <code>EXT4</code>, <code>HFS+</code>, <code>NTFS</code>, <code>XFS</code>, <code>ZFS</code>. Some filesystems (e.g. <code>ZFS</code> and <code>Btrfs</code>) have logical volume manager built-in.</p><p>Due to the role it plays in the operating systems stack (abstracting low-level block layer to higher-level file layer), almost all filesystems run inside the kernel. This is why once the filesystem is mounted, no one (not even the user programs) cares about it in consumer operating systems.</p><p>However, if you need high-tech features (compression, encryption), or want to fine-tune performance or redundancy, then you should care very much about the filesystem.</p><h3 id=mounting-the-filesystem>Mounting the filesystem</h3><p>To use the filesystems, or to be able to read/write files, the OS will have to mount the filesystems. For example, mounting an <code>EXT4</code> filesystem on partition <code>/dev/sda4</code> means that the OS is using a program called <code>EXT4</code> to handle the <code>EXT4</code>-formatted data on <code>/dev/sda4</code>, thus providing access to the files in the filesystem.</p><p>This is why you usually can&rsquo;t mess with the FS, e.g. using <code>fsck</code>, or resizing the FS when the FS is mounted. It is because the filesystem program is actively handling the partition - altering it is not possible on most filesystems, although some modern filesystems like <code>Btrfs</code> and <code>ZFS</code> can do this.</p><p>When you mount a filesystem to a mountpoint, its files is available for access at the mountpoint. For example, if I have mounted a filesystem on my flash drive at <code>/mnt</code>, I can now access its files at <code>/mnt</code>. Doing <code>$ ls /mnt;</code> will list the files contained in the filesystem of the flash drive.</p><p><strong>Filesystems must be mounted</strong> first before users and other programs can <em>read or write a file in a filesystem</em> (as opposed to working on raw block storage like <code>dd</code> and <code>dump</code>). In UNIX-like systems, the <code>mount</code> program and <code>fstab</code> works together to mount system partitions at boot time.</p><h3 id=fstab>fstab</h3><p>In simplest terms, <code>fstab</code> is a text file containing each <em>entry</em> of filesystem mounts in a line. Each line has 7 fields, and all 7 fields must be specified otherwise the mount fails. <a href=https://wiki.archlinux.org/index.php/Fstab>Here is what I think is a good guide</a> to (Arch) Linux <code>fstab</code>. I always recommend using UUID for <a href=https://wiki.archlinux.org/index.php/Persistent_block_device_naming>persistent block device naming</a>.</p><p><code>fstab</code> is the first file I learned to <em>master</em> on UNIX-like systems. It caused headaches, especially boot problems during my early UNIX days as I broke the file by copy-pasting random lines from Google results. In short, <strong>one must master <code>fstab</code></strong>.</p><blockquote><p>For partitions that are not required to boot, adding <code>nofail</code> and <code>noauto</code> in the mount options is sometimes recommended to avoid boot failure if such partitions are not available at boot time.</p></blockquote><h2 id=why-use-filesystem-instead-of-writing-raw-data>Why use filesystem instead of writing raw data</h2><p>Operating systems manages various I/O services for user applicatons, and file storage is one of them. If the OS does not use a filesystem, all user programs must include functions that provide file read/write access. This is where filesystems come in handy - it helps abstract the file layer in our storage stack. The filesystem works together with the <a href=/cheat/noob/block/>block device</a> driver, usually within the kernel, to provide safe, uniform file read/write access for user programs.</p><h2 id=my-recommended-filesystems>My recommended filesystems</h2><p>When deciding filesystems to use, my criteria usually includes:</p><h3 id=specific-requirement>Specific requirement</h3><p>For example, some scenarios require a specific type of FS. One example is the ESP, or the EFI System Partition, which must always be formatted in <code>FAT</code>.</p><h3 id=data-integrity>Data integrity</h3><p>Since FS is what keeps our data safe (as files), we usually don&rsquo;t want it to break. Some great FS also talks with hardware to ensure the spinning rust doesn&rsquo;t fuck up. My top pick for data integrity is <code>ZFS</code>, and with its flexible VDEV configuration, I would say it is bulletproof FS. It&rsquo;s called the billion-dollar filesystem after all, y&rsquo;all!?</p><h3 id=native-support>Native support</h3><p>Having native support for your filesystem guarantees a smooth experience. Examples of native FS on Linux are <code>EXT4</code>, and <code>Btrfs</code>, while there are <code>FAT</code>, <code>exFAT</code>, and <code>NTFS</code> for the Windows camp.</p><h3 id=features>Features</h3><p>Built-in compression, encryption, or journaling can be helpful if you have a particular scenario in mind. I usually end up preferring newer filesystems like ZFS or Btrfs because they have copy-on-Write, friendliness to flash storage, and compression. Some filesystems also include built-in volume manager, which gives huge flexibility in data storage.</p><p>My top pick for FS with best features is ZFS, because it does so with minimum risks of losing data as evidence by the test of time.</p><hr><p><a href=#top>Back to top</a></p><hr><footer><p>Copyright (c) 2019 Prem Phansuriyanon</p><p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p></footer></body></html>